import argparse
import io
import sys

import httpx
import pydantic


class SchoolidoluAccountMiniCenter(pydantic.BaseModel):
    id: int
    card: int


class SchoolidoluAccountItems(pydantic.BaseModel):
    tickets: int | None = None
    g: int | None = None
    vouchers: int | None = None
    friend_points: int | None = None


class SchoolidoluUserAccount(pydantic.BaseModel):
    id: int
    owner: str
    nickname: str | None = None
    friend_id: int | None = None
    language: str
    center: SchoolidoluAccountMiniCenter | None = None
    rank: int | None = None
    items: SchoolidoluAccountItems | None = None

    @pydantic.computed_field
    @property
    def invite_code(self) -> str | None:
        return None if self.friend_id is None else f"{self.friend_id:09d}"


class SchoolidoluUser(pydantic.BaseModel):
    username: str
    accounts: list[SchoolidoluUserAccount] | None


class SchoolidoluPaginated[T](pydantic.BaseModel):
    count: int
    next: str | None
    previous: str | None
    results: list[T]


class SchoolidoluOwnedCard(pydantic.BaseModel):
    id: int
    owner_account: int
    card: int
    stored: str
    idolized: bool
    max_level: bool
    max_bond: bool
    skill: int
    skill_slots: int


class SchoolidoluTeam(pydantic.BaseModel):
    id: int
    name: str
    owner_account: int
    members: list[SchoolidoluOwnedCard] | None


class SchoolidoluCard(pydantic.BaseModel):
    id: int
    game_id: int


def list_user_accounts(username: str, json_output: bool):
    with httpx.Client() as client:
        response = client.get(f"https://schoolido.lu/api/users/{username}/?expand_accounts=true")
        response.raise_for_status()
        user_data = SchoolidoluUser.model_validate(response.json())

    if not isinstance(user_data.accounts, list) or len(user_data.accounts) == 0:
        raise Exception(f"user '{username}' does not have any accounts")

    if json_output:
        import json

        print(
            json.dumps(
                [
                    {
                        "account_id": account.id,
                        "name": account.nickname,
                        "language": account.language,
                        "invite_code": account.invite_code,
                    }
                    for account in user_data.accounts
                ],
                indent="\t",
            )
        )
    else:
        for account in user_data.accounts:
            print(f"{account.nickname} {account.language}, account ID: {account.id}")


async def retrieve_paginated[T](cls: type[T], client: httpx.AsyncClient, start_url: str):
    result: list[T] = []
    target_url = start_url
    while target_url is not None:
        response = await client.get(target_url)
        response.raise_for_status()
        paginated_data = SchoolidoluPaginated[cls].model_validate(response.json())
        target_url = paginated_data.next
        result.extend(paginated_data.results)
    return result


async def convert_to_npps4_script(
    f: io.StringIO,
    account_data: SchoolidoluUserAccount,
    cards: list[SchoolidoluOwnedCard],
    teams: list[SchoolidoluTeam],
    client: httpx.AsyncClient,
):
    import datetime

    import sqlalchemy

    import npps4.script_dummy  # isort:skip
    import npps4.idol
    import npps4.db.unit
    import npps4.system.unit

    unit_number_info: dict[int, npps4.db.unit.Unit] = {}
    sit_unit_number_to_unit_id: dict[int, int] = {}

    async def get_unit_info_by_number(context: npps4.idol.BasicSchoolIdolContext, unit_number: int, /):
        if unit_number not in unit_number_info:
            q = sqlalchemy.select(npps4.db.unit.Unit).where(npps4.db.unit.Unit.unit_number == unit_number).limit(1)
            result = await context.db.unit.execute(q)
            unit_info = result.scalar()
            if unit_info is None:
                print(
                    f"Warning: card number {unit_number} does not exist. Asking SchoolIdolu for actual unit_id...",
                    file=sys.stderr,
                )
                if unit_number not in sit_unit_number_to_unit_id:
                    response = await client.get(f"https://schoolido.lu/api/cards/{unit_number}/")
                    response.raise_for_status()
                    card_info = SchoolidoluCard.model_validate(response.json())
                    sit_unit_number_to_unit_id[unit_number] = card_info.game_id
                unit_info = await context.db.unit.get(npps4.db.unit.Unit, sit_unit_number_to_unit_id[unit_number])

            if unit_info is None:
                raise Exception(f"card number {unit_number} does not exist")
            unit_number_info[unit_number] = unit_info
        else:
            unit_info = unit_number_info[unit_number]
        return unit_info

    lang_literal = "npps4.idol.Language.en" if account_data.language == "EN" else "npps4.idol.Language.jp"
    print("# Autogenerated by import_from_schoolidolu.py at", str(datetime.datetime.now()), file=f)
    print(file=f)
    print("import npps4.idol", file=f)
    print("import npps4.db.main", file=f)
    print("import npps4.scriptutils.user", file=f)
    print("import npps4.system.album", file=f)
    print("import npps4.system.handover", file=f)
    print("import npps4.system.unit", file=f)
    print("import npps4.system.user", file=f)
    print(file=f)
    print("async def run_script(args: list[str]):", file=f)
    print("    cmap: dict[int, npps4.db.main.Unit] = {}", file=f)
    print(file=f)
    print("    async with npps4.idol.BasicSchoolIdolContext(", lang_literal, ") as context:", sep="", file=f)
    print("        # Create new user", file=f)
    print("        user = await npps4.system.user.create(context, None, None)", file=f)
    print("        user.name =", repr(account_data.nickname or "Newcomer"), file=f)
    print("        await npps4.scriptutils.user.simulate_completion(context, user)", file=f)
    print(file=f)

    lang = npps4.idol.Language.en if account_data.language == "EN" else npps4.idol.Language.jp
    async with npps4.idol.BasicSchoolIdolContext(lang) as context:
        print("        # Club members.", file=f)
        for card in cards:
            if card.stored == "Deck":
                unit_info = await get_unit_info_by_number(context, card.card)
                target_level = 1
                if card.max_level:
                    match unit_info.rarity:
                        case 5:
                            target_level = 90 if card.idolized else 70
                        case 4:
                            target_level = 100 if card.idolized else 80
                        case 3:
                            target_level = 80 if card.idolized else 60
                        case 2:
                            target_level = 60 if card.idolized else 40
                        case 1:
                            target_level = 40 if card.idolized else 30

                print(
                    "        # #",
                    unit_info.unit_number,
                    " - https://sif.kirara.ca/card/",
                    unit_info.unit_number,
                    sep="",
                    file=f,
                )
                print(
                    "        unit_data = await npps4.system.unit.create_unit(context, user, ",
                    unit_info.unit_id,
                    ", True, level=",
                    target_level,
                    ")",
                    sep="",
                    file=f,
                )
                print("        assert unit_data is not None", file=f)
                if card.idolized:
                    print("        await npps4.system.unit.idolize(context, user, unit_data)", file=f)
                if await npps4.system.unit.has_signed_variant(context, unit_info.unit_id):
                    print("        unit_data.is_signed = True", file=f)
                print("        unit_data.skill_exp = 0 # TODO", file=f)  # TODO
                print(
                    "        unit_data.unit_removable_skill_capacity =",
                    min(card.skill_slots, unit_info.max_removable_skill_capacity),
                    file=f,
                )
                print("        await npps4.system.unit.add_unit_by_object(context, user, unit_data)", file=f)
                print("        cmap[", card.id, "] = unit_data", sep="", file=f)
        if account_data.center is not None:
            print("        # Set partner", file=f)
            print(
                "        await npps4.system.unit.set_unit_center(context, user, cmap[",
                account_data.center.id,
                "])",
                sep="",
                file=f,
            )
        print(file=f)

        print("        # Team formation.", file=f)
        for i, team in enumerate(teams, 1):
            if team.members:
                unit_ids = ", ".join(f"cmap[{team.members[j].id}].id" for j in range(9))
                print("        # Team", chr(64 + i), "-", team.name, file=f)
                print(
                    "        deck_data, _ = await npps4.system.unit.load_unit_deck(context, user, ",
                    i,
                    ", True)",
                    sep="",
                    file=f,
                )
                print("        deck_data.name =", repr(team.name), file=f)
                print(
                    "        await npps4.system.unit.save_unit_deck(context, user, deck_data, [",
                    unit_ids,
                    "])",
                    sep="",
                    file=f,
                )
        print(file=f)

        print("        # Album.", file=f)
        for card in cards:
            if card.stored == "Album":
                unit_info = await get_unit_info_by_number(context, card.card)
                print(
                    "        await npps4.system.album.update(context, user, ",
                    unit_info.unit_id,
                    ", rank_max=",
                    repr(card.idolized),
                    ", love_max=",
                    repr(card.idolized and card.max_bond),
                    ", rank_level_max=",
                    repr(card.idolized and card.max_level),
                    ", sign_flag=",
                    repr(await npps4.system.unit.has_signed_variant(context, unit_info.unit_id)),
                    ")  # https://sif.kirara.ca/card/",
                    unit_info.unit_number,
                    sep="",
                    file=f,
                )
        print(file=f)

    print("        # Generate transfer passcode", file=f)
    print("        transfer_code = npps4.system.handover.generate_transfer_code()", file=f)
    print(
        "        user.transfer_sha1 = npps4.system.handover.generate_passcode_sha1(user.invite_code, transfer_code)",
        file=f,
    )
    print('        print("Transfer ID:", user.invite_code)', file=f)
    print('        print("Transfer Passcode:", transfer_code)', file=f)
    print(file=f)
    print('if __name__ == "__main__":', file=f)
    print("    import npps4.scriptutils.boot", file=f)
    print("    npps4.scriptutils.boot.start(run_script)", file=f)
    print(file=f)


async def process_account(account_id: int):
    async with httpx.AsyncClient(timeout=httpx.Timeout(timeout=30)) as client:
        response = await client.get(f"https://schoolido.lu/api/accounts/{account_id}/")
        response.raise_for_status()
        account_data = SchoolidoluUserAccount.model_validate(response.json())

        # Retrieve paginated data
        cards = await retrieve_paginated(
            SchoolidoluOwnedCard,
            client,
            f"https://schoolido.lu/api/ownedcards/?owner_account={account_id}&page_size=15",
        )
        teams = await retrieve_paginated(
            SchoolidoluTeam, client, f"https://schoolido.lu/api/teams/?owner_account={account_id}&page_size=15"
        )

        with io.StringIO() as f:
            await convert_to_npps4_script(f, account_data, cards, teams, client)
            return f.getvalue()


def run_formatter(python_code: str):
    try:
        import black
        import black.mode

        return black.format_str(
            python_code, mode=black.Mode(line_length=120, target_versions={black.mode.TargetVersion.PY312})
        )
    except ImportError:
        print("Unable to import black formatter. Resulting Python code will be not formatted.", file=sys.stderr)
        return python_code


async def run_script(args: list[str]):
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    subparser = parser.add_subparsers(dest="command", required=True)

    list_parser = subparser.add_parser("list")
    list_parser.add_argument("username", help="Username to list accounts.")
    list_parser.add_argument("--json", help="Output machine-readable format.", action="store_true")

    import_parser = subparser.add_parser("import")
    import_parser.add_argument(
        "account_id", help='Account ID number, use "list" command to show account ID numbers.', type=int
    )
    import_parser.add_argument("output", help="Output python script.", default=None)
    import_parser.add_argument("--run", help="Run resulting script directly.", action="store_true")
    parser_args = parser.parse_args(args)

    match parser_args.command:
        case "list":
            list_user_accounts(parser_args.username, parser_args.json)
        case "import":
            python_script = run_formatter(await process_account(parser_args.account_id))

            if parser_args.output is not None:
                with open(parser_args.output, "w", encoding="utf-8") as f:
                    f.write(python_script)
            else:
                import sys

                sys.stdout.write(python_script)

            if parser_args.run:
                exec(python_script)


if __name__ == "__main__":
    import npps4.scriptutils.boot

    npps4.scriptutils.boot.start(run_script)
